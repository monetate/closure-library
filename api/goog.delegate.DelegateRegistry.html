<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>goog.delegate.DelegateRegistry</title><link href="dossier.css" rel="stylesheet" type="text/css"><script src="types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="dossier-main"><main data-page-data="[null,[[[&quot;goog.delegate.DelegateRegistry&quot;,null,null,null,[null,371,null,[null,null,&quot;closure/goog/delegate/delegateregistry.js&quot;],[null,null,&quot;https://github.com/google/closure-library/blob/master/closure/goog/delegate/delegateregistry.js#L371&quot;]],null,[[[null,&quot;&lt;p&gt;Delegates provide a system for hygienic modification of a delegating class&amp;#39;s\nbehavior.  The basic idea is that, rather than monkey-patching prototype\nmethods, a class can instead provide extension points by calling out to\ndelegates.  Later code can then register delegates, and when the delegating\nclass is instantiated, any registered delegates will be instantiated and\nreturned.&lt;/p&gt;\n&lt;p&gt;The usage has four parts:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;A &lt;em&gt;delegate interface&lt;/em&gt; is defined to provide specific overridable hooks.\nThis can be a simple function &lt;code&gt;&amp;#64;typedef&lt;/code&gt;, or an entire &lt;code&gt;&amp;#64;interface&lt;/code&gt; or\n&lt;code&gt;&amp;#64;record&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;A &lt;em&gt;delegate registry&lt;/em&gt; for this interface is instantiated, often as a\nstatic field on the interface.&lt;/li&gt;&lt;li&gt;One or more &lt;em&gt;delegates&lt;/em&gt; are defined that implement this interface.\nDelegates are registered with the registry.  Different registry classes\nsupport different policies for registering more than one delegate.&lt;/li&gt;&lt;li&gt;After delegates are registered, the delegating class asks the registry for\nthe &lt;em&gt;list of delegates&lt;/em&gt;, which are then instantiated if necessary.&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;In some circumstances (particularly if a delegate method will be called from\nmultiple places) it may make sense to provide an additional wrapper between\nthe delegate list and the delegating (sometimes called &amp;#34;modded&amp;#34;) class, to\nensure that the delegates are used correctly.&lt;/p&gt;\n&lt;h2&gt;Example usage&lt;/h2&gt;\n&lt;p&gt;For example, consider a class &lt;code&gt;Foo&lt;/code&gt; that wants to provide a few extension\npoints for the behaviors &lt;code&gt;zorch&lt;/code&gt; and &lt;code&gt;snarf&lt;/code&gt;.  We can set up the delegation\nas follows:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;&lt;/code&gt;&lt;/p&gt;&lt;code&gt;&lt;pre&gt;\nconst DelegateRegistry &amp;#61; goog.require(&amp;#39;goog.delegate.DelegateRegistry&amp;#39;);\nconst delegates &amp;#61; goog.require(&amp;#39;goog.delegate.delegates&amp;#39;);\nclass Foo {\nconstructor() {\n/** &amp;#64;private &amp;#64;const {!Array&amp;lt;!Foo.Delegate&amp;gt;} */\nthis.delegates_ &amp;#61; Foo.registry.delegates();\n}\nfrobnicate(x, y, z) {\nconst w &amp;#61; delegates.callFirst(this.delegates_, d &amp;#61;&amp;gt; d.zorch(x, y));\nreturn this.delegates_.map(d &amp;#61;&amp;gt; d.snarf(z, w));\n}\n}\n/** &amp;#64;interface */\nFoo.Delegate &amp;#61; class {\nzorch(a, b) {}\nsnarf(a, b) {}\n}\n/** &amp;#64;const {!DelegateRegistry&amp;lt;!Foo.Delegate&amp;gt;} */\nFoo.registry &amp;#61; new DelegateRegistry();\n&lt;/pre&gt;&lt;/code&gt;\n&lt;p&gt;A file inserted later in the bundle can define a delegate and register itself\nwith the registry:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;&lt;/code&gt;&lt;/p&gt;&lt;code&gt;&lt;pre&gt;\n/** &amp;#64;implements {Foo.Delegate} */\nclass WibblyFooDelegate {\nzorch(a, b) { return a &amp;#43; b; }\nsnarf(a, b) { return a - b; }\n}\nFoo.registry.registerClass(WibbyFooDelegate);\n&lt;/pre&gt;&lt;/code&gt;\n&lt;p&gt;In many cases, the delegates need to be initialized with an instance of the\nmodded class.  To support this, a function may be passed to the &lt;code&gt;delegates()&lt;/code&gt;\nmethod to override how the constructor is called.&lt;/p&gt;\n&lt;h2&gt;Multiple Delegates&lt;/h2&gt;\n&lt;p&gt;Two different registry classes are defined, each with a different policy for\nhow to handle multiple delegates.  The simpler one, &lt;code&gt;DelegateRegistry&lt;/code&gt;,\nallows multiple delegates to be registered and returns them in the order they\nwere registered.  If only one delegate is expected,\n&lt;code&gt;DelegateRegistry.prototype.expectAtMostOneDelegate()&lt;/code&gt; performs assertions\n(in debug mode) that at most one delegate is added, though in production\nmode it will still register them all - The use of &lt;code&gt;delegate()&lt;/code&gt; or\n&lt;code&gt;goog.delegate.delegates.callFirst()&lt;/code&gt; is recommended in this case to ensure\nreasonable behavior.&lt;/p&gt;\n&lt;p&gt;The more sophisticated one, &lt;code&gt;DelegateRegistry.Prioritized&lt;/code&gt;, requires passing\na unique priority to each delegate registration (collisions are asserted in\ndebug mode, but will fall back to registration order in production).&lt;/p&gt;\n&lt;h2&gt;Wrapped Delegator&lt;/h2&gt;\n&lt;p&gt;In some cases it makes sense to wrap the delegate list in a dedicated\ndelegator object, rather than having the modded class use it directly:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;&lt;/code&gt;&lt;/p&gt;&lt;code&gt;&lt;pre&gt;\n/** &amp;#64;record */\nclass MyDelegateInterface {\n/** &amp;#64;param {number} arg */\nfoo(arg) {}\n/** &amp;#64;return {number|undefined} */\nbar() {}\n/** &amp;#64;return {string} */\nbaz() {}\n}\nclass MyDelegator {\n/** &amp;#64;param {!Array&amp;lt;!MyDelegateInterface&amp;gt;} delegates */\nconstructor(delegates) { this.delegates_ &amp;#61; delegates; }\n/** &amp;#64;param {number} */\nfoo(arg) { this.delegates_.forEach(d &amp;#61;&amp;gt; d.foo(arg)); }\n/** &amp;#64;return {number} */\nbar() {\nconst result &amp;#61;\ndelegates.callUntilNotNullOrUndefined(this.delegates_, d &amp;#61;&amp;gt; d.bar());\nreturn result !&amp;#61; null ? result : 42;\n}\n/** &amp;#64;return {!Array} */\nbaz() { return this.delegates_.map(d &amp;#61;&amp;gt; d.baz()); }\n}\n&lt;/pre&gt;&lt;/code&gt;\n&lt;p&gt;In this example, the modded class will call into the delegates via the\nwrapper class, ensuring that the correct calling convention is always used.&lt;/p&gt;\n&quot;]]],[null,null,null,null,null,1],null,[],null,[],[],[[&quot;DelegateRegistry&quot;,[null,371,null,[null,null,&quot;closure/goog/delegate/delegateregistry.js&quot;],[null,null,&quot;https://github.com/google/closure-library/blob/master/closure/goog/delegate/delegateregistry.js#L371&quot;]],[[[null,&quot;&lt;p&gt;Delegates provide a system for hygienic modification of a delegating class&amp;#39;s\nbehavior.  The basic idea is that, rather than monkey-patching prototype\nmethods, a class can instead provide extension points by calling out to\ndelegates.  Later code can then register delegates, and when the delegating\nclass is instantiated, any registered delegates will be instantiated and\nreturned.&lt;/p&gt;\n&lt;p&gt;The usage has four parts:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;A &lt;em&gt;delegate interface&lt;/em&gt; is defined to provide specific overridable hooks.\nThis can be a simple function &lt;code&gt;&amp;#64;typedef&lt;/code&gt;, or an entire &lt;code&gt;&amp;#64;interface&lt;/code&gt; or\n&lt;code&gt;&amp;#64;record&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;A &lt;em&gt;delegate registry&lt;/em&gt; for this interface is instantiated, often as a\nstatic field on the interface.&lt;/li&gt;&lt;li&gt;One or more &lt;em&gt;delegates&lt;/em&gt; are defined that implement this interface.\nDelegates are registered with the registry.  Different registry classes\nsupport different policies for registering more than one delegate.&lt;/li&gt;&lt;li&gt;After delegates are registered, the delegating class asks the registry for\nthe &lt;em&gt;list of delegates&lt;/em&gt;, which are then instantiated if necessary.&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;In some circumstances (particularly if a delegate method will be called from\nmultiple places) it may make sense to provide an additional wrapper between\nthe delegate list and the delegating (sometimes called &amp;#34;modded&amp;#34;) class, to\nensure that the delegates are used correctly.&lt;/p&gt;\n&lt;h2&gt;Example usage&lt;/h2&gt;\n&lt;p&gt;For example, consider a class &lt;code&gt;Foo&lt;/code&gt; that wants to provide a few extension\npoints for the behaviors &lt;code&gt;zorch&lt;/code&gt; and &lt;code&gt;snarf&lt;/code&gt;.  We can set up the delegation\nas follows:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;&lt;/code&gt;&lt;/p&gt;&lt;code&gt;&lt;pre&gt;\nconst DelegateRegistry &amp;#61; goog.require(&amp;#39;goog.delegate.DelegateRegistry&amp;#39;);\nconst delegates &amp;#61; goog.require(&amp;#39;goog.delegate.delegates&amp;#39;);\nclass Foo {\nconstructor() {\n/** &amp;#64;private &amp;#64;const {!Array&amp;lt;!Foo.Delegate&amp;gt;} */\nthis.delegates_ &amp;#61; Foo.registry.delegates();\n}\nfrobnicate(x, y, z) {\nconst w &amp;#61; delegates.callFirst(this.delegates_, d &amp;#61;&amp;gt; d.zorch(x, y));\nreturn this.delegates_.map(d &amp;#61;&amp;gt; d.snarf(z, w));\n}\n}\n/** &amp;#64;interface */\nFoo.Delegate &amp;#61; class {\nzorch(a, b) {}\nsnarf(a, b) {}\n}\n/** &amp;#64;const {!DelegateRegistry&amp;lt;!Foo.Delegate&amp;gt;} */\nFoo.registry &amp;#61; new DelegateRegistry();\n&lt;/pre&gt;&lt;/code&gt;\n&lt;p&gt;A file inserted later in the bundle can define a delegate and register itself\nwith the registry:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;&lt;/code&gt;&lt;/p&gt;&lt;code&gt;&lt;pre&gt;\n/** &amp;#64;implements {Foo.Delegate} */\nclass WibblyFooDelegate {\nzorch(a, b) { return a &amp;#43; b; }\nsnarf(a, b) { return a - b; }\n}\nFoo.registry.registerClass(WibbyFooDelegate);\n&lt;/pre&gt;&lt;/code&gt;\n&lt;p&gt;In many cases, the delegates need to be initialized with an instance of the\nmodded class.  To support this, a function may be passed to the &lt;code&gt;delegates()&lt;/code&gt;\nmethod to override how the constructor is called.&lt;/p&gt;\n&lt;h2&gt;Multiple Delegates&lt;/h2&gt;\n&lt;p&gt;Two different registry classes are defined, each with a different policy for\nhow to handle multiple delegates.  The simpler one, &lt;code&gt;DelegateRegistry&lt;/code&gt;,\nallows multiple delegates to be registered and returns them in the order they\nwere registered.  If only one delegate is expected,\n&lt;code&gt;DelegateRegistry.prototype.expectAtMostOneDelegate()&lt;/code&gt; performs assertions\n(in debug mode) that at most one delegate is added, though in production\nmode it will still register them all - The use of &lt;code&gt;delegate()&lt;/code&gt; or\n&lt;code&gt;goog.delegate.delegates.callFirst()&lt;/code&gt; is recommended in this case to ensure\nreasonable behavior.&lt;/p&gt;\n&lt;p&gt;The more sophisticated one, &lt;code&gt;DelegateRegistry.Prioritized&lt;/code&gt;, requires passing\na unique priority to each delegate registration (collisions are asserted in\ndebug mode, but will fall back to registration order in production).&lt;/p&gt;\n&lt;h2&gt;Wrapped Delegator&lt;/h2&gt;\n&lt;p&gt;In some cases it makes sense to wrap the delegate list in a dedicated\ndelegator object, rather than having the modded class use it directly:&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;&lt;/code&gt;&lt;/p&gt;&lt;code&gt;&lt;pre&gt;\n/** &amp;#64;record */\nclass MyDelegateInterface {\n/** &amp;#64;param {number} arg */\nfoo(arg) {}\n/** &amp;#64;return {number|undefined} */\nbar() {}\n/** &amp;#64;return {string} */\nbaz() {}\n}\nclass MyDelegator {\n/** &amp;#64;param {!Array&amp;lt;!MyDelegateInterface&amp;gt;} delegates */\nconstructor(delegates) { this.delegates_ &amp;#61; delegates; }\n/** &amp;#64;param {number} */\nfoo(arg) { this.delegates_.forEach(d &amp;#61;&amp;gt; d.foo(arg)); }\n/** &amp;#64;return {number} */\nbar() {\nconst result &amp;#61;\ndelegates.callUntilNotNullOrUndefined(this.delegates_, d &amp;#61;&amp;gt; d.bar());\nreturn result !&amp;#61; null ? result : 42;\n}\n/** &amp;#64;return {!Array} */\nbaz() { return this.delegates_.map(d &amp;#61;&amp;gt; d.baz()); }\n}\n&lt;/pre&gt;&lt;/code&gt;\n&lt;p&gt;In this example, the modded class will call into the delegates via the\nwrapper class, ensuring that the correct calling convention is always used.&lt;/p&gt;\n&quot;]]],null,null,[null,null,null,null,null,1],null,null,[],[]],[&quot;T&quot;],1,[],null,[]],[[[&quot;allowLateRegistration&quot;,[null,67,null,[null,null,&quot;closure/goog/delegate/delegateregistry.js&quot;],[null,null,&quot;https://github.com/google/closure-library/blob/master/closure/goog/delegate/delegateregistry.js#L67&quot;]],[[[null,&quot;&lt;p&gt;Configures this registry to allow late registration.  Normally it is an\nerror to register a delegate after calling &lt;code&gt;delegate()&lt;/code&gt; or &lt;code&gt;delegates()&lt;/code&gt;.\nIf late registration is allowed, then this is no longer an error.  This\ncheck only ever happens in debug mode.  Returns this.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;module$contents$goog$delegate$DelegateRegistry_DelegateRegistryBase&quot;,null,null,null,[]],null,[],[]],[&quot;THIS&quot;],null,[],[null,[null,null,null,[&quot;THIS&quot;,null,null,null,[]]]],[]],[[&quot;cacheInstantiation&quot;,[null,82,null,[null,null,&quot;closure/goog/delegate/delegateregistry.js&quot;],[null,null,&quot;https://github.com/google/closure-library/blob/master/closure/goog/delegate/delegateregistry.js#L82&quot;]],[[[null,&quot;&lt;p&gt;Configures this registry to automatically cache instantiated instances,\nrather than calling the constructor every time &lt;code&gt;delegates()&lt;/code&gt; is called.\nReturns this.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;module$contents$goog$delegate$DelegateRegistry_DelegateRegistryBase&quot;,null,null,null,[]],null,[],[]],[&quot;THIS&quot;],null,[],[null,[null,null,null,[&quot;THIS&quot;,null,null,null,[]]]],[]],[[&quot;delegate&quot;,[null,95,null,[null,null,&quot;closure/goog/delegate/delegateregistry.js&quot;],[null,null,&quot;https://github.com/google/closure-library/blob/master/closure/goog/delegate/delegateregistry.js#L95&quot;]],[[[null,&quot;&lt;p&gt;Returns the first (highest priority) registered delegate, or undefined\nif none was registered.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;module$contents$goog$delegate$DelegateRegistry_DelegateRegistryBase&quot;,null,null,null,[]],null,[],[]],[],null,[[&quot;instantiate&quot;,[1,null,[null,null,[[null,null,[1,[null,null,null,null,null,[[[null,null,null,[&quot;T&quot;,null,null,null,[]]],[null,null,null,null,null,null,null,null,null,1]]]],[[null,1,null,null,null,null,null,1]]]]],[null,null,null,null,null,[[[null,null,null,[&quot;T&quot;,null,null,null,[]]],[null,null,null,null,null,null,null,null,null,1]]]]]],[[[null,&quot;&lt;p&gt;A function to\ninstantiate constructors registered with &lt;code&gt;registerClass&lt;/code&gt;.  By default,\nthis just calls the constructor with no arguments.&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;delegates&quot;,[null,114,null,[null,null,&quot;closure/goog/delegate/delegateregistry.js&quot;],[null,null,&quot;https://github.com/google/closure-library/blob/master/closure/goog/delegate/delegateregistry.js#L114&quot;]],[[[null,&quot;&lt;p&gt;Returns an array of all registered delegates, creating a fresh instance\nof any registered classes.  The &lt;code&gt;instantiate&lt;/code&gt; argument can be passed to\noverride how constructors are called.  The array will be frozen in debug\nmode.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;module$contents$goog$delegate$DelegateRegistry_DelegateRegistryBase&quot;,null,null,null,[]],null,[],[]],[],null,[[&quot;instantiate&quot;,[1,null,[null,null,[[null,null,[1,[null,null,null,null,null,[[[null,null,null,[&quot;T&quot;,null,null,null,[]]],[null,null,null,null,null,null,null,null,null,1]]]],[[null,1,null,null,null,null,null,1]]]]],[null,null,null,null,null,[[[null,null,null,[&quot;T&quot;,null,null,null,[]]],[null,null,null,null,null,null,null,null,null,1]]]]]],[[[null,&quot;&lt;p&gt;A function to\ninstantiate constructors registered with &lt;code&gt;registerClass&lt;/code&gt;.  By default,\nthis just calls the constructor with no arguments.&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,null,null,[[[null,null,null,[&quot;T&quot;,null,null,null,[]]],[null,null,null,null,null,null,null,null,null,1]]]]]]]],[]],[[&quot;expectAtMostOneDelegate&quot;,[null,285,null,[null,null,&quot;closure/goog/delegate/delegateregistry.js&quot;],[null,null,&quot;https://github.com/google/closure-library/blob/master/closure/goog/delegate/delegateregistry.js#L285&quot;]],[[[null,&quot;&lt;p&gt;Configures this registry to accept at most one delegate.\nThis only affects debug mode.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;goog.delegate.DelegateRegistry&quot;,null,[null,null,[null,null,&quot;goog.delegate.DelegateRegistry.html&quot;]],null,[[null,null,null,null,null,[[[null,null,null,[&quot;T&quot;,null,null,null,[]]],[null,null,null,null,null,null,null,null,null,1]]]]]]]],[]],[[&quot;registerClass&quot;,[null,295,null,[null,null,&quot;closure/goog/delegate/delegateregistry.js&quot;],[null,null,&quot;https://github.com/google/closure-library/blob/master/closure/goog/delegate/delegateregistry.js#L295&quot;]],[[]],null,null,null,null,null,[],[]],[],null,[[&quot;ctor&quot;,[null,null,[1,[null,null,null,null,null,[[[null,null,null,[&quot;T&quot;,null,null,null,[]]],[null,null,null,null,null,null,null,null,null,1]]]],[[null,1,null,null,null,null,null,1]]]]]],null,[]],[[&quot;registerInstance&quot;,[null,303,null,[null,null,&quot;closure/goog/delegate/delegateregistry.js&quot;],[null,null,&quot;https://github.com/google/closure-library/blob/master/closure/goog/delegate/delegateregistry.js#L303&quot;]],[[]],null,null,null,null,null,[],[]],[],null,[[&quot;instance&quot;,[null,null,null,null,null,[[[null,null,null,[&quot;T&quot;,null,null,null,[]]],[null,null,null,null,null,null,null,null,null,1]]]]]],null,[]]],[],null,[[&quot;module$contents$goog$delegate$DelegateRegistry_DelegateRegistryBase&quot;,null,null,null,[[null,null,null,[&quot;T&quot;,null,null,null,[]]]]]],[],[],[[&quot;goog.delegate.DelegateRegistry&quot;,null,[null,null,[null,null,&quot;goog.delegate.DelegateRegistry.html&quot;]],null,[]],null,1],null,&quot;goog.delegate.DelegateRegistry.html&quot;,&quot;goog.delegate.DelegateRegistry&quot;,[],[],[],[]]]]]"></main><footer><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></footer></div><script src="dossier.js" defer></script>